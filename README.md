### Multi Social API with Devise, OmniAuth for Facebook, Twitter, Linkedin 
- Objective to have single user identity linked to multiple OAuth identities 
- Even if multiple OAuth identities have different emails associated with each social platform
- Twitter doesn't share user's email, so we need to get from user
- Ability to have User deselect or select multiple social logins from within their profile 
- and activate them all so, they can login with any of their profiles
- If user doesn't want to use a social login they can create a user account using devise 

#### Base application generated by my template.rb (github.com/KudosX/template.rb):
- Gemset ruby-2.3.0@rails5.0.0.beta3
- Ruby 2.3.0
- Rails 5.0.0.beta3

#### MVC Overview:
- will split models into User and Identity, Identity is for multiple OAuth identities
- will use controllers; application, omniauth_callbacks, sessions
- will use devise and custom views

#### Gems for this project (pinterest, instagram for future addition)
```
gem 'devise'
gem 'therubyracer'
gem 'omniauth-facebook'
gem 'omniauth-twitter'
gem 'omniauth-linkedin'
gem 'omniauth-pinterest'
gem 'omniauth-instagram'
```
* if you have problems making therubyracer gem work in mac try this:
```
brew install v8-315
bundle config --local build.libv8 --with-system-v8
bundle config --local build.therubyracer --with-v8-dir=/usr/local/opt/v8-315
bundle install
```
#### References for this project for login
- https://github.com/plataformatec/devise/wiki/OmniAuth%3A-Overview
- https://github.com/plataformatec/devise/wiki/OmniAuth-with-multiple-models
- https://github.com/intridea/omniauth/wiki/Managing-Multiple-Providers
- https://github.com/intridea/omniauth/wiki/List-of-Strategies
- https://github.com/arunagw/omniauth-twitter
- https://github.com/skorks/omniauth-linkedin
- https://github.com/mkdynamic/omniauth-facebook
- https://github.com/jot/omniauth-pinterest/
- http://www.sitepoint.com/series/authentication-in-rails/
- http://sourcey.com/rails-4-omniauth-using-devise-with-twitter-facebook-and-linkedin/

#### References to tweet as the authenticated user and post with facebook (not implemented):
- https://github.com/sferik/twitter
- https://richonrails.com/articles/sending-a-tweet-to-twitter
- https://launchschool.com/blog/facebook-graph-api-using-omniauth-facebook-and-koala
- http://snippets.aktagon.com/snippets/512-how-to-post-a-message-to-the-facebook-wall-with-omniauth-devise
- http://revelry.co/a-beginners-guide-to-using-the-facebook-api-in-your-rails-application-part-1/

#### Step 1: setup devise
- `rails g devise:install` devise outputs some manual steps, be sure to do steps 1, 3, 5 manually, 
- `rails g devise User` creates User model
- Note: if your server is running be sure to stop the server before running rake command
- `rake db:migrate` to create database

#### Step 2: copy all devise views into application
- `rails g devise:views` creates views/devise

#### Step 3: add action to not serve up pages until user authenticated:
add `before_action :authenticate_user!, :except => [:index, :about, :contact, :faq]` 
to application_controller just before `end`

#### Step 4: to view routes
`rake routes` to see list of existing routes
- localhost:3000/users/sign_in
- localhost:3000/users/sign_up

#### Step 5: create additional models and controllers
- create identity model
- `rails g model identity provider:string uid:string user_id:integer`
- create a sessions controller for actions `rails g controller sessions`
- create a omniauth_callbacks controller `rails g controller omniauth_callbacks`
- run `rake db:migrate`

#### Step 6: get client ID(KEY) and SECRET from OAuth providers, we will do twitter first
- https://dev.twitter.com/oauth/overview/application-owner-access-tokens
- https://apps.twitter.com to create your application
- Twitter: http://127.0.0.1:3000/users/auth/twitter/callback , can't use "localhost" in callback
- after we are done with application we will go back and do the others so, not to conflate our problems

#### Step 7: add ENVIRONMENT VARIABLES to .bash_profile on mac 
- for development mode only
- `nano .bash_profile` will open your bash file
- replace between " " with credentials received from twitter
- NOTE: close terminal to reset .bash_profile when done
```
export TWITTER_KEY="xxxxxkey_from_twitter_apixxxxxx"
export TWITTER_SECRET="xxxxxxsecret_from_twitter_apixxxxxx"
```

#### Step 8: add OmniAuth configuration, ENVIRONMENT VARIABLES to omniauth.rb
- create config/omniauth.rb file and add the following
```
Rails.application.config.middleware.use OmniAuth::Builder do
  provider :twitter, ENV['TWITTER_KEY'], ENV['TWITTER_SECRET']
  provider :facebook, ENV['FACEBOOK_ID'], ENV['FACEBOOK_SECRET']
  provider :linkedin, ENV['CONSUMER_KEY'], ENV['CONSUMER_SECRET']
end 
```
- setup omniauth's "on_failure" hook outside OmniAuth configuration block
- add the following code in same file just below block in omniauth.rb
- `OmniAuth.config.on_failure = Proc.new { |env| SessionsController.action(:failure).call(env) }`       
             
#### Step 9: add some convenience methods for creating identities and users for callback
- add to models/user.rb
```
class User < ApplicationRecord
  has_many :identities
  def self.create_with_omniauth(info)
    create(name: info['name'])
  end
end
```
- add to models/identity.rb
```
class Identity < ApplicationRecord
  belongs_to :user
  validates_presence_of :uid, :provider
  validates_uniqueness_of :uid, :scope => :provider
  def self.find_with_omniauth(auth)
    find_by(uid: auth['uid'], provider: auth['provider'])
  end
  def self.create_with_omniauth(auth)
    create(uid: auth['uid'], provider: auth['provider'])
  end
end
```

#### Step 10: handle logging in and logging out
- setup a callback in routes.rb
```
devise_for :users, :controllers => { :omniauth_callbacks => 'omniauth_callbacks' }
match '/auth/:provider/callback', to: 'sessions#create', via: [:get, :post]
match '/logout', to: 'sessions#destroy', via: [:get, :post]
```

#### Step 11: managing session data
- have your sessions_controller.rb look like this
```
class SessionsController < ApplicationController
  def create
    # Login the User here
  end
  def destroy
    # Logout the User here
  end
get "/auth/:provider/callback" => "sessions#create"
end
```

- have your application_controller.rb look like this
```
class ApplicationController < ActionController::Base
  # Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  protect_from_forgery with: :exception
  before_action :authenticate_user!, :except => [:index, :about, :contact, :faq]
  protected
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
  def signed_in?
    !!current_user
  end
  helper_method :current_user, :signed_in?
  def current_user=(user)
    @current_user = user
    session[:user_id] = user.nil? ? nil : user.id
  end
end
```

#### Step 12: handle some edge cases in logging in such as
1. user signing in with a different provider from previous login
2. a user is logged in with a provider but they try to login with same provider again
3. a user is logged in but they try to login with a different provider
- need to grab authentication data given to us by provider which is stored in `request.env['omniauth.auth']`
- then compare to whether we have this identity or create a new one
- in case #3 above we are going to link their new request to their identity
- have your sessions_controller.rb look like this
```
class SessionsController < ApplicationController
  def create
    auth = request.env['omniauth.auth']
    # Find an identity here
    @identity = Identity.find_with_omniauth(auth)
    if @identity.nil?
      # If no identity was found, create a brand new one here
      @identity = Identity.create_with_omniauth(auth)
    end
    if signed_in?
      if @identity.user == current_user
        # User is signed in so they are trying to link an identity with their
        # account. But we found the identity and the user associated with it 
        # is the current user. So the identity is already associated with 
        # this user. So let's display an error message.
        redirect_to root_url, notice: "Already linked that account!"
      else
        # The identity is not associated with the current_user so lets 
        # associate the identity
        @identity.user = current_user
        @identity.save
        redirect_to root_url, notice: "Successfully linked that account!"
      end
    else
      if @identity.user.present?
        # The identity we found had a user associated with it so let's 
        # just log them in here
        self.current_user = @identity.user
        redirect_to root_url, notice: "Signed in!"
      else
        # No user associated with the identity so we need to create a new one
        redirect_to new_user_url, notice: "Please finish registering"
      end
    end
  end
  def destroy
    self.current_user = nil
      redirect_to root_url, notice: "Signed out!"
  end
  get "/auth/:provider/callback" => "sessions#create"
end
```

#### Step 13: setting up controller/omniauth_callbacks_controller.rb
- code should look like the following for twitter provider
```
class OmniauthCallbacksController < Devise::OmniauthCallbacksController
  def twitter
    # You need to implement the method below in your model (e.g. app/models/user.rb)
    @user = User.from_omniauth(request.env["omniauth.auth"])
    if @user.persisted?
      sign_in_and_redirect @user, :event => :authentication #this will throw if @user is not activated
      set_flash_message(:notice, :success, :kind => "Twitter") if is_navigational_format?
    else
      session["devise.twitter_data"] = request.env["omniauth.auth"]
      redirect_to new_user_registration_url
    end
  end
  def failure
    redirect_to root_path
  end
end
```
- all information retrieved from twitter by OmniAuth is available as a hash at `request.env["omniauth.auth"]`
- more information here: https://github.com/intridea/omniauth/wiki/Auth-Hash-Schema
- twitter hash info here: https://github.com/arunagw/omniauth-twitter#authentication-hash
- when a valid user is found, they can be signed in with one of two Devise methods: `sign_in` 
- or `sign_in_and_redirect`. Passing `:event => :authentication` is optional
- more info here: https://stackoverflow.com/questions/9221390/what-does-event-authentication-do/13389324#13389324
- in case user is not persisted, we store OmniAuth data in the session and redirect to registration

#### Step 14: add method in models/user.rb
```
def self.from_omniauth(auth)
  where(provider: auth.provider, uid: auth.uid).first_or_create do |user|
    user.email = auth.info.email
    user.password = Devise.friendly_token[0,20]
    user.name = auth.info.name   # assuming the user model has a name
    user.image = auth.info.image # assuming the user model has an image
  end
end
```
- this method tries to find an existing user by the provider and uid fields
- if no user is found, a new one is created with a random password and some extra information
- the `first_or_create` method automatically sets the provider and uid fields when creating new user
- the one with a !, `first_or_create!` method operates similarly, except that i will raise an exception if user record fails validation
- we are using the one without a !

#### Step 15: Not Working


#### Step xxx: add a migration
- stop server, run `rails g migration add_user_to_identities user:references`



